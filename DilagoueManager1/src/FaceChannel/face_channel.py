#!/usr/bin/env python

from Utils import imageProcessingUtil, modelDictionary, modelLoader
import numpy
import tensorflow as tf

import rospy

from sensor_msgs.msg import Image
from dialogue_manager.msg import Emotion

from cv_bridge import CvBridge, CvBridgeError

import keras.backend.tensorflow_backend as tb

import os
#import cv2

os.chdir(os.path.dirname(__file__))

rospy.init_node('face_channel', anonymous=True)
category_pub = rospy.Publisher('emotion_channel', Emotion, queue_size=10)

bridge = CvBridge()

config = tf.compat.v1.ConfigProto()
config.gpu_options.allow_growth=True
sess = tf.compat.v1.Session(config=config)

finalImageSize = (1024,768) # Size of the final image generated by the demo
faceSize = (64,64) # Input size for both models: categorical and dimensional

modelDimensional = modelLoader.modelLoader(modelDictionary.DimensionalModel)
#modelCategorical = modelLoader.modelLoader(modelDictionary.CategoricaModel)

imageProcessing = imageProcessingUtil.imageProcessingUtil()

def callback(data):
        #to prevent "'thread._local' object has no attribute 'value'" error
        tb._SYMBOLIC_SCOPE.value = True

        try:
            frame = bridge.imgmsg_to_cv2(data)
        except CvBridgeError as err:
            rospy.loginfo(err)
        
        # detect faces
        facePoints, face = imageProcessing.detectFace(frame)
        
        # create display image and copy the captured frame to it
        image = numpy.zeros((finalImageSize[1], finalImageSize[0], 3), numpy.uint8)
        image[0:480, 0:640] = frame
        frame = image

        '''

        cv2.imshow('pepper', frame)

        if cv2.waitKey(33) == 27:
            return

        '''

         # If a face is detected
        if not len(face) == 0:
            # pre-process the face
            face = imageProcessing.preProcess(face, faceSize)
            
            # Obtain dimensional classification
            dimensionalRecognition = numpy.array(modelDimensional.classify(face))
            
            #Obtain Categorical classification
            #categoricalRecognition = modelCategorical.classify(face)[0]

            msg = [dimensionalRecognition[0],  #happy
                   dimensionalRecognition[1],  #sad
                   0,                          #surprise
                   0,                          #anger
                   0,                          #disgust
                   0,                          #fear
                   0]                          #neutral

            category_pub.publish(msg)


def listener():
    rospy.Subscriber('camera_channel', Image, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()
